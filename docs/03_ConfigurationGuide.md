# CheckMk Configuration Guide

This guide provides step-by-step instructions for configuring notifications like suggested in the User Storys

## Activate state change on overload

> Setup > Services monitoring rules > CPU utilization for simple devices : 

**In a new rule set theses parameters :** 

- **Description :** *CPUOver90*
- **[x]Levels over an extended time period on total CPU utilization :** *80.0%*
- **Warning after :** *30 secs (other values to 0)*
- **Critical after :** *1 mins (other values to 0)*
- **Explicit Hosts [x] :** *MON-WinServer*

## Script for discord notification

> CHECK_MK doesn't have a default script made for sending discord notification. So we are forced to use a custom script, using python by default (python is native with check_mk).

```python
#!/usr/bin/env python3
# This script has been generated by DeepSeek with different instructions. 
import os
import requests
import json
import hashlib
from datetime import datetime
from pathlib import Path

# Configuration
WEBHOOK_URL = "webhook_url"
STATE_FILE = "/tmp/checkmk_discord_state.log"
DEDUP_WINDOW = 300  # 5-minute deduplication window

def escape_discord(text):
    """Escape special Discord markdown characters"""
    return text.replace('_', r'\_').replace('*', r'\*').replace('~', r'\~') if text else ""

def get_alert_fingerprint():
    """Create unique hash for current alert"""
    return hashlib.md5(f"{os.environ.get('NOTIFY_HOSTNAME','')}_{os.environ.get('NOTIFY_SERVICEDESC','')}_{os.environ.get('NOTIFY_SERVICESTATE','')}".encode()).hexdigest()

def is_duplicate_notification(fingerprint):
    """Check for recent duplicate alerts"""
    try:
        if not Path(STATE_FILE).exists():
            return False

        with open(STATE_FILE, 'r') as f:
            for line in f.readlines():
                stored_fp, timestamp = line.strip().split('|')
                if stored_fp == fingerprint and (datetime.now() - datetime.fromtimestamp(float(timestamp))).seconds < DEDUP_WINDOW:
                    return True
        return False
    except:
        return False

def record_notification(fingerprint):
    """Log sent notifications"""
    with open(STATE_FILE, 'a') as f:
        f.write(f"{fingerprint}|{datetime.now().timestamp()}\n")

def get_custom_message(state):
    """Return state-specific messages with your exact wording"""
    return {
        "OK": {
            "color": 65280,       # Green
            "emoji": "✅",
            "title": "Service Recovery",
            "description": "The Windows server services are recovered.",
            "details": "Every services are working correctly.",
            "footer": "System back to normal operation"
        },
        "WARNING": {
            "color": 16776960,    # Yellow
            "emoji": "⚠️",
            "title": "Performance Warning",
            "description": "The Windows server services could be slower.",
            "details": "You could have network failure and file access deprecated.",
            "footer": "Investigate when possible"
        },
        "CRITICAL": {
            "color": 16711680,    # Red
            "emoji": "🚨",
            "title": "Service Outage",
            "description": "The Windows server services are down.",
            "details": "The network could not work correctly and your file access aren't sure.",
            "footer": "Immediate action required"
        }
    }.get(state, {
        "color": 3553599,        # Gray (default)
        "emoji": "ℹ️",
        "title": "Service Notification",
        "description": f"Service state changed to {state}",
        "details": os.environ.get('NOTIFY_SERVICEOUTPUT', 'No details available'),
        "footer": "CheckMK Monitoring"
    })

try:
    # Deduplication check
    alert_id = get_alert_fingerprint()
    if is_duplicate_notification(alert_id):
        exit(0)

    # Get environment variables
    host = escape_discord(os.environ.get('NOTIFY_HOSTNAME', 'Unknown Server'))
    service = escape_discord(os.environ.get('NOTIFY_SERVICEDESC', 'Windows Services'))
    state = os.environ.get('NOTIFY_SERVICESTATE', 'UNKNOWN')

    # Get custom message configuration
    msg = get_custom_message(state)

    # Prepare Discord embed
    embed = {
        "title": f"{msg['emoji']} {msg['title']} - {host} {msg['emoji']}",
        "color": msg["color"],
        "description": msg["description"],
        "fields": [
            {"name": "🖥️ Server", "value": host, "inline": True},
            {"name": "🔧 Service", "value": service, "inline": True},
            {"name": "📢 Status Update", "value": msg["details"]}
        ],
        "footer": {
            "text": msg["footer"],
            "icon_url": "https://checkmk.com/favicon.ico"
        },
        "timestamp": os.environ.get('NOTIFY_SHORTDATETIME', '')
    }

    # Send to Discord
    response = requests.post(
        WEBHOOK_URL,
        json={"embeds": [embed]},
        headers={"Content-Type": "application/json"},
        timeout=10
    )
    response.raise_for_status()

    # Record successful notification
    record_notification(alert_id)

except Exception as e:
    with open("/tmp/checkmk_discord_errors.log", "a") as f:
        f.write(f"{datetime.now()} - Error: {str(e)}\n")
    raise
```
> The script has to be in the following directory and has to be executable (chmod +x) : 
~/omd/sites/LaboMonitoring/local/share/check_mk/notifications

The script will:

- Receiving state (Critical, OK, Warning)
- Format a notification / message depending on the state
- Use a WebHook URL to send the notification on discord
- Note error messsage in the process in a state file mention as a variable

## Sending notifications on changing state

> Setup > Notifications : 

**In a new rule set theses parameters :** 

- **[x]Service events :** *State change -> From OK to WARN*
- **[x]Hosts :** *MON-WinServer*
- **[x]Services :** *^CPU\**
- **Send notification :** *discord (script name) -> Select parameters (random parameters)*
- **Select recipient :** *All users*
- **Description :** *CPU - Warning - Windows - discord*

> **!** This rule can be setup for different state. The script manage these state changement : 
- OK -> WARN
- WARN -> CRITICAL
- CRITICAL -> OK